generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  avatar    String?
  phone     String?
  role      UserRole @default(READER)
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  borrowedBooks BorrowedBook[]
  reviews       Review[]
  reservations  Reservation[]
  favorites     FavoriteBook[]
  notifications Notification[]
  refreshTokens RefreshToken[] // Зворотний зв'язок до RefreshToken

  @@map("users")
}

model Author {
  id          String   @id @default(cuid())
  firstName   String
  lastName    String
  bio         String?
  birthDate   DateTime?
  deathDate   DateTime?
  nationality String?
  photo       String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  books Book[]

  @@map("authors")
}




model Book {
  id              String      @id @default(cuid())
  isbn            String?     @unique
  title           String
  description     String?
  coverImage      String?
  publicationYear Int?
  publisher       String?
  language        String
  pages           Int?
  totalCopies     Int         @default(1)
  availableCopies Int         @default(1)
  status          BookStatus  @default(AVAILABLE)
  createdAt       DateTime    @default(now())
  updatedAt       DateTime    @updatedAt

  // Relations
  authorId    String
  author      Author        @relation(fields: [authorId], references: [id], onDelete: Cascade)
  categoryId  String
  category    Category      @relation(fields: [categoryId], references: [id], onDelete: Cascade)
  borrowed    BorrowedBook[]
  reviews     Review[]
  reservations Reservation[]
  favorites   FavoriteBook[]
  bookGenres  BookGenre[]

  @@map("books")
}

model Category {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  books Book[]

  @@map("categories")
}

model Genre {
  id          String   @id @default(cuid())
  name        String   @unique
  description String?
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Relations
  bookGenres BookGenre[]

  @@map("genres")
}

model BookGenre {
  id      String @id @default(cuid())
  bookId  String
  genreId String

  // Relations
  book  Book  @relation(fields: [bookId], references: [id], onDelete: Cascade)
  genre Genre @relation(fields: [genreId], references: [id], onDelete: Cascade)

  @@unique([bookId, genreId])
  @@map("book_genres")
}

model BorrowedBook {
  id              String         @id @default(cuid())
  borrowedDate    DateTime       @default(now())
  dueDate         DateTime
  returnedDate    DateTime?
  status          BorrowStatus   @default(BORROWED)
  renewalCount    Int            @default(0)
  lateFee         Decimal?       @default(0)
  createdAt       DateTime       @default(now())
  updatedAt       DateTime       @updatedAt

  // Relations
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookId String
  book   Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("borrowed_books")
}

model Review {
  id        String   @id @default(cuid())
  rating    Int      // 1-5 stars
  comment   String?
  isApproved Boolean @default(false)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  // Relations
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookId String
  book   Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
  @@map("reviews")
}

model Reservation {
  id         String       @id @default(cuid())
  status     ReservationStatus @default(ACTIVE)
  reservedAt DateTime     @default(now())
  expiresAt  DateTime
  notifiedAt DateTime?
  createdAt  DateTime     @default(now())
  updatedAt  DateTime     @updatedAt

  // Relations
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  bookId String
  book   Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@map("reservations")
}
model RefreshToken {
  id        String   @id @default(cuid())
  token     String   @unique
  userId    String
   user      User     @relation(fields: [userId], references: [id], onDelete: Cascade) 
  
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("refresh_tokens")
}

model FavoriteBook {
  id      String @id @default(cuid())
  userId  String
  bookId  String

  // Relations
  user User @relation(fields: [userId], references: [id], onDelete: Cascade)
  book Book @relation(fields: [bookId], references: [id], onDelete: Cascade)

  @@unique([userId, bookId])
  @@map("favorite_books")
}

model Notification {
  id        String           @id @default(cuid())
  type      NotificationType
  title     String
  message   String
  isRead    Boolean          @default(false)
  createdAt DateTime         @default(now())
  readAt    DateTime?

  // Relations
  userId String
  user   User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@map("notifications")
}


model PasswordResetToken {
  id        String   @id @default(cuid())
  token     String   @unique
  email     String
  expiresAt DateTime
  createdAt DateTime @default(now())

  @@map("password_reset_tokens")
}



// Enums
enum UserRole {
  READER
  LIBRARIAN
  ADMIN
}

enum BookStatus {
  AVAILABLE
  BORROWED
  RESERVED
  MAINTENANCE
  LOST
}

enum BorrowStatus {
  BORROWED
  RETURNED
  OVERDUE
  LOST
}

enum ReservationStatus {
  ACTIVE
  FULFILLED
  CANCELLED
  EXPIRED
}

enum NotificationType {
  BOOK_AVAILABLE
  DUE_DATE_REMINDER
  OVERDUE_NOTICE
  RESERVATION_EXPIRING
  SYSTEM_ANNOUNCEMENT
}



